[{"categories":["Block Chain"],"content":"共识机制概念梳理 区块链系统作为一个分布式系统，受限于网络延迟和停电断电等极端情况，为了维持一个一致的系统，首先要解决一致性问题。与此同时，区块链系统又具有去中心化的特征，各个节点相对独立，没有中心节点对于其他节点的恶意行为进行约束。在这样的背景下，需要设立一套制度，使得众多节点能够有序的改变系统的状态，同时使得系统的一致性的以保证。 ","date":"2021-03-17","objectID":"/pos/:0:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/pos/"},{"categories":["Block Chain"],"content":"共识 共识，关注的是多个提议者达成一致的过程，共识算法本质上解决的是如何在分布式系统下保证所有节点共同认可某个结果，其中需要考虑节点宕机，网络时延，网络分区等各种问题。 ","date":"2021-03-17","objectID":"/pos/:1:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/pos/"},{"categories":["Block Chain"],"content":"CAP定理 理想化的场景下，整个系统中所有节点的数据都是相同的，可以任何节点读取或写入数据，产生的效果相同（一致性）；即使某些节点出现故障，系统依然能够正确响应用户请求（可用性）；即使两个节点发生分区，或者说通信中断，集群依然可以继续运行（分区容限）。而由Eric Brewer提出，Lynch等人证明的CAP定理明确了这三种性质不可兼得。所有可用的组合包括： CA：所有节点之间的数据都是一致的，只要所有节点都处于联机状态，就可以从任何节点进行读/写操作，并确保数据相同，但是如果节点之间发生分区，则数据将是不同步（解决分区后将不会重新同步）。 CP：所有节点之间的数据都是一致的，并且当节点发生故障时变得不可用，从而保持分区容限（防止数据失步）。 AP：节点即使无法彼此通信也将保持联机状态，并且在解析分区后将重新同步数据，但是不能保证所有节点（在分区期间或分区之后）都具有相同的数据 同时满足一致性，可用性和分区容限的系统是并不存在的。假设存在三个节点$${A, B, C}$$用于维护同一份数据，处于某种原因，$$C$$和$${A, B}$$当一个写请求到达$$C$$并要求更新其状态时，$$C$$存在两种选择： 即使知道A和B无法同步更新数据仍然接收该请求。 拒绝请求，等待与A，B恢复通信后提供服务。 选择前者，即选择可用性而放弃了一致性；选择后者，即选择一致性而放弃了可用性，两者不可兼得。实际上在大规模的分布式应用当中，网络不可靠几乎不可避免，即分区容限是必须的选择，因此C和A不可兼得，系统设计者必须在AP和CP之间权衡[1]。 对于CAP定理的使用的解释和应用，应当落脚于当出现问题时，在三种性质中在哪一方面做出妥协：不保证线性一致性、不保证完全的可用性、或者对于网络状况做提出更高的要求，而不是在三者之中选择提供哪两者。 由于CAP中对C和A的定义过度理想化，有人提出了BASE理论，只要求基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。核心思想在于即使无法做到强一致性，仍可以根据业务特性，使用适当的方式使得系统达到最终一致性。许多分布式系统都是基于“基本可用”和“最终一致性”来构建的。关于一致性模型的讨论，在这篇文章[2]中有更深入的讨论。 总而言之，在共识机制的设计中，也涉及到一系列的妥协，追求的是在各个目标之间找到某种平衡。 ","date":"2021-03-17","objectID":"/pos/:1:1","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/pos/"},{"categories":["Block Chain"],"content":"共识机制 即达成共识的机制，依据系统对故障组件的容错能力分为崩溃容错协议(crash fault tolerant,CFT)和拜占庭容错协议（Byzantine fault tolerant,BFT)[3]。 在崩溃容错协议中，如果组件出现故障，系统仍能够正确的达成共识。拜占庭容错协议中，即使存在恶意节点，系统仍能够正确工作。二者的区别主要在于对于威胁/错误模型的不同假设。[4] CFT can withstand up to N/2 system failures, while no guarantees on adversary nodes. BFT provides with guarantees to withstand and correctly reach consensus in presence of N/3 failures of any kind including Byzantine. You can think of it as two phase commit versus three phase commit. PoW的机制在wiki[5]中有清晰的描述。 PoS的思想在这篇博客中[6]有深入的思考。核心思想在于在PoW机制中，攻击者和防御者的代价可能是一比一的，对于一个攻击者的51%攻击，需要整个社区几乎相等的算力以挽回其代价，而PoS中，攻击者作恶的代价远高于防御者，与此同时，攻击者的攻击行为带来的收益相对较小。当一个攻击者的攻击行为被发现之后，社区只需要对链做一次分叉，则攻击者的投入以及其收益即全部报销，而对于其他人以及整个系统而言，并没有带来显著的影响，主要思想是通过经济学原理限制作恶。 ","date":"2021-03-17","objectID":"/pos/:2:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/pos/"},{"categories":["Block Chain"],"content":"参考资料 [1]You Can’t Sacrifice Partition Tolerance [2]一致性杂谈 [3]Wikipedia 共识机制 [4]Byzantine fault tolerance (BFT) and Crash fault tolerance (CFT) [5]Wikipedia 工作量证明 [6]A proof of stake design philosophy ","date":"2021-03-17","objectID":"/pos/:3:0","tags":["共识机制"],"title":"共识机制概念梳理","uri":"/pos/"},{"categories":["misc"],"content":"在Manjaro下运行一个Ubuntu 在物理机上安装了两个Linux发行版，以应对不同的应用需求，但相互切换频繁操作繁琐，于是开始折腾如何在已经启动一个Linux安装之后使用安装在另一个分区的Linux发行版。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:0:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"1 方案一：修改fstab挂载分区 直接打开Manjaro后，在文件管理器中可以直接打开Ubuntu所在的分区，但是由于每次动态挂载回导致路径不固定，不方便于后续的折腾。可在/etc/fstab文件中添加对于Ubuntu所在分区的挂载，将其挂载到固定的位置。 使用lsblk -f命令找到相应分区的UUID，在/etc/fstab文件中添加挂载的配置条目。 UUID=\u003cUUID\u003e /ubuntu ext4 defaults,noatime 0 1 挂载后，部分软件已经可以直接使用了，例如基于Java的Vivado，在挂载之后可以直接在其安装目录下运行命令，打开图形界面进行使用。但这是因为Vivado是跑在Java虚拟机中的，本机安装了Java之后不需要额外的依赖环境。尝试执行ELF格式的软件时，将会发现部分软件缺少依赖的动态库而无法直接运行，这时仅挂载目录的方案就不能完全解决问题了。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:1:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"2 方案二：mount+chroot 将主机的/proc目录/sys目录/run/udev目录/dev目录绑定到Ubuntu文件系统的相应位置，注意由于这些目录均为虚拟文件目录，不必担心这样的绑定破坏了Ubuntu文件系统的完整性。 mount -t proc /proc /ubuntu/proc mount --rbind /dev /ubuntu/dev mount --bind /run /ubuntu/run mount --bind /tmp /ubuntu/tmp 在host操作系统中打开一个新的Xserver并监听，注意需要先使用xhost允许来自localhost的连接。 sudo xhost +local: sudo X -quiet -nolisten tcp -noreset :1 vt2 chroot到Ubuntu操作系统中之后指定使用的DISPLAY端口，即可在相应的tty中执行GUI应用程序。 例如：DISPLAY=:1 firefox。或者也可以直接指定DISPLAY=:0，使用主机的桌面环境。 这一方法可以支撑ELF格式的软件的执行，但问题在于可能没有办法使用网络。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:2:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"3 方案三：systemd-nspawn 直接使用systemd-nspawn指令，可用于在一个轻量命名空间容器中运行命令或操作系统。它比 chroot 更强大在于它完全虚拟化了文件系统层次结构、进程树、各种 IPC 子系统以及主机和域名。 通过该指令可直接在container中运行一个受限的Ubuntu操作系统，通过systemd-nspawn，可以直接在另一个tty中打开一个ubuntu的gnome桌面。 将操作封装为函数添加到.zshrc以便重用。 function spawn_ubuntu() { sudo xhost +local: sudo X -quiet -nolisten tcp -noreset :1 vt2 \u003e\u003e /dev/null 2\u003e\u00261 \u0026#打开Xserver sudo systemd-nspawn -bD /ubuntu \\ --bind=/lib/modules \\ --bind-ro=/tmp/.X11-unix \\ --bind=/mnt #非必要 } 在终端中直接输入spawn_ubuntu便可直接使用Ubuntu了，终端中登录后使用 DISPLAY=:1 gnome-session 在tty2中打开gnome桌面环境，通过Ctrl + Alt + \u003ctty_num\u003e在不同的tty之间进行切换。 ","date":"2020-10-19","objectID":"/systemd-nspawn/:3:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["misc"],"content":"参考文献 fstab wiki Chroot with second desktop environment - Howto and notes systemd-nspawn wiki ","date":"2020-10-19","objectID":"/systemd-nspawn/:4:0","tags":["Manjaro"],"title":"在Manjaro下运行一个Ubuntu","uri":"/systemd-nspawn/"},{"categories":["OS"],"content":"RISC-V 特权级切换 UCAS的计算机专业操作系统实验中要求实现sleep系统调用，涉及到RISC-V的一些细节，需要阅读手册理解该指令集下的工作机制，在此做一总结。 ","date":"2020-10-18","objectID":"/riscv-syscall/:0:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"1 切换运行模式至用户态 实验手册的注意事项中给出了如下提示： RISC-V 在所有特全级下都用ecall执行系统调用。Supervisor态ecall会触发machine态的例外，user态的ecall会触发supervisor态的中断。所以大家务必注意，要让USER模式的进程/线程运行在用户态。 Supervisor模式和User模式的切换是后续顺利实验的关键。《RISC-V手册》第10章关于特权架构的介绍中提到： S 模式有几个异常处理 CSR:sepc、stvec、scause、sscratch、stval 和 sstatus,它们执行与 M 模式 CSR 相同的功能。监管者异常返回指令 sret 与 mret 的行为相同,但它作用于 S 模式的异常处理 CSR,而不是 M 模式的 CSR。S 模式处理例外的行为已和 M 模式非常相似。如果 hart 接受了异常并且把它委派给了S 模式,则硬件会原子地经历几个类似的状态转换,其中用到了 S 模式而不是 M 模式的CSR: 发生例外的指令的 PC 被存入 sepc,且 PC 被设置为 stvec。 scause 根据异常类型设置,stval 被设置成出错的地址或者其它特定异常的信息字。 把 sstatus CSR 中的 SIE 置零,屏蔽中断,且 SIE 之前的值被保存在 SPIE 中。 发生例外时的权限模式被保存在 sstatus 的 SPP 域,然后设置当前模式为 S 模式。 这一部分描述了从User模式进入到Supervisor模式的过程中硬件的处理机制，从Supervisor模式返回User模式的过程手册中没有直接介绍，但可以通过对mret的介绍了解其工作方式。 处理程序用 mret 指令(M 模式特有的指令)返回。mret 将 PC 设置为 mepc,通过将 mstatus 的 MPIE 域复制到MIE 来恢复之前的中断使能设置,并将权限模式设置为 mstatus 的 MPP 域中的值。 这基本是前一段中描述的逆操作。 显然想要将运行模式切换到用户态，需要的指令就是sret了。 在执行sret之前，需要准备好sepc，sstatus寄存器，这一部分寄存器应当在恢复上下文时完成，需要特别关注sstatus的SPIE位以及SPP位，这为初始化PCB时的设计给出了提示。具体实现可通过阅读手册中对于sret指令的说明得到一些提示。 ","date":"2020-10-18","objectID":"/riscv-syscall/:1:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"2 系统调用 ecall指令我们在Project 1的SBI_CALL中见到过，当时的用法是通过寄存器传参后调用sbi函数，这是在Supervisor模式下的行为。如果读者在没有完成上下文切换的时候尝试过使用ecall指令触发中断，并仔细调试的话，预期触发中断的地方很可能直接执行了一个sbi函数。而若已经正确切换到User模式，将会跳转到stvec继续执行，异常类型存放在scause中，stval 被设置成出错的地址或者其它特定异常的信息字。后续系统调用的实现就很简单了，不再赘述。 祝大家实验顺利。 ","date":"2020-10-18","objectID":"/riscv-syscall/:2:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"3 参考文献 RISC-V 手册 P2-Guidebook-RISCV ","date":"2020-10-18","objectID":"/riscv-syscall/:3:0","tags":["Lab"],"title":"RISC-V 特权级切换","uri":"/riscv-syscall/"},{"categories":["OS"],"content":"操作系统实验环境配置 操作系统实验中，利用qemu运行RISCV架构下的操作系统，gdb远程调试。利用vscode给gdb提供图形界面的支持可以极大的改善调试体验。 ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:0:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"1 安装Native Debug插件 Native DebugNative Debug \" Native Debug ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"2 配置Lauch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"gdb\", \"request\": \"attach\", \"name\": \"Attach to QEMU\", //替换为自己的可执行文件路径 \"executable\": \"${workspaceFolder}/prj2/main\", //将端口替换为当前实验中qemu打开的端口，例如xv6习惯于使用26000 \"target\": \"localhost:1234\", \"remote\": true, \"cwd\": \"${workspaceRoot}\", //替换为相应的gdb可执行文件的地址 \"gdbpath\": \"/riscv64-linux/bin/riscv64-unknown-linux-gnu-gdb\", \"autorun\": [ //添加其他需要的文件提供调试信息 \"add-symbol-file ${workspaceFolder}/prj2/bootblock\", //在入口函数下断点 \"b _start\" ] }, ] } ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["OS"],"content":"3 愉快调试 在终端中启动qemu后，F5打开调试器，程序将自动停止在设定的断点处。 debugdebug \" debug Tips: 使用侧边栏调试窗口中的Call Stack查看调用栈 Debug Console中照常使用gdb打印信息 在.gdbinit中自定义宏，打印信息,例如: define plist set $hd = (list_node_t*)\u0026ready_queue set $nd = ready_queue-\u003enext while($nd != $hd) p/x $nd set $nd = ((list_node_t*)$nd)-\u003enext end end define pcur printf \"current_running-\u003ekernel_sp= %lx\",current_running-\u003ekernel_sp printf \"current_running-\u003euser_sp= %lx\",current_running-\u003euser_sp printf \"context:\\n\" x/36gx current_running-\u003ekernel_sp end 示例： pcurpcur \" pcur 祝大家调试愉快。 ","date":"2020-10-17","objectID":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","tags":["Lab"],"title":"内核调试环境配置","uri":"/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["环境配置"],"content":"Configure manjaro ","date":"2020-09-01","objectID":"/manjaro-configure/:0:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Change sources ","date":"2020-09-01","objectID":"/manjaro-configure/:1:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"rank mirrors sudo pacman-mirrors -i -c China -m rank sudo pacman -Syu ","date":"2020-09-01","objectID":"/manjaro-configure/:1:1","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the gem source gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/ ","date":"2020-09-01","objectID":"/manjaro-configure/:1:2","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the npm source npm install -g nrm // 全局安装nrm模块 nrm ls // 显示所有可用的源 nrm use taobao // 切换到淘宝源： ","date":"2020-09-01","objectID":"/manjaro-configure/:2:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"change the bundle source bundle config mirror.https://rubygems.org https://mirrors.tuna.tsinghua.edu.cn/rubygems ","date":"2020-09-01","objectID":"/manjaro-configure/:3:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"add archlinuxcn and arch4edu #edit /etc/pacman.conf #append the following content [archlinuxcn] SigLevel = Optional TrustedOnly Server = http://mirrors.ustc.edu.cn/archlinuxcn/$arch [arch4edu] SigLevel = Never Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch add the archlinuxcn-keyring sudo pacman -S archlinuxcn-keyring sudo pacman -Syu ","date":"2020-09-01","objectID":"/manjaro-configure/:3:1","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"add blackarch # Run https://blackarch.org/strap.sh as root and follow the instructions. $ curl -O https://blackarch.org/strap.sh # The SHA1 sum should match: 9f770789df3b7803105e5fbc19212889674cd503 strap.sh $ sha1sum strap.sh # Set execute bit $ chmod +x strap.sh # Run strap.sh $ sudo ./strap.sh #change the source #edit the /etc/pacman.conf [blackarch] SigLevel = Optional TrustAll Server = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch # add keyring first ","date":"2020-09-01","objectID":"/manjaro-configure/:3:2","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Necessary software zsh sudo pacman -S manjaro-zsh-config chsh -s /bin/zsh yay sudo pacman -S yay chrome typora nvim code anaconda goldendict sudo pacman -S google-chrome typora code goldendict rime-pinyin sudo pacman -S fctix-rime kcm-fcitx fcitx-gtk2 fcitx-gtk3#need to log out gdb\u0026radare2\u0026pwntools sudo pacman -S pwndbg peda gef radare2 ghidra sudo pacman -S ghidra vmware sudo pacman -S vmware-workstation Remember to install the right linux-headers before using vmware, and start the networking. systemctl start vmware-networks.service systemctl enable vmware-networks.service metasploit sudo pacman -S msfdb metasploit ","date":"2020-09-01","objectID":"/manjaro-configure/:4:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Configure the environment asystem time synchronize sudo timedatectl set-local-rtc true mount the windows partion UUID=0CB47F55B47F406E /mnt/C ntfs-3g defaults 0 0 UUID=585245C85245AB96 /mnt/D ntfs-3g defaults 0 0 ","date":"2020-09-01","objectID":"/manjaro-configure/:5:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"},{"categories":["环境配置"],"content":"Backup backup with clonezilla restore the grub ","date":"2020-09-01","objectID":"/manjaro-configure/:6:0","tags":["Manjaro"],"title":"Manjaro","uri":"/manjaro-configure/"}]